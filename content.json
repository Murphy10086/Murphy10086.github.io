{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://localhost:4000","root":"/"},"pages":[],"posts":[{"title":"Java基础之方法详解","slug":"Java基础之方法详解","date":"2021-10-17T13:36:59.000Z","updated":"2021-10-17T13:41:25.037Z","comments":true,"path":"2021/10/17/Java基础之方法详解/","link":"","permalink":"http://localhost:4000/2021/10/17/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"JAVA 异常分类及处理 异常分类Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception Error Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果 出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。 Exception （ RuntimeException、CheckedException ） Exception 又有两个分支，一个是运行时异常 RuntimeException ，一个是 CheckedException。 RuntimeException 如 ： NullPointerException 、 ClassCastException ；一个是检查异常 CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是 那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一 定是程序员的错误. 13/04/2018 Page 102 of 283 检查异常 CheckedException ：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强 制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一 般包括几个方面： 试图在文件尾部读取数据 试图打开一个错误格式的 URL 试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在 异常的处理方式遇到问题不进行具体处理，而是继续抛给调用者 （ throw,throws ） 抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常 。 12345678910public static void main(String[] args) &#123; String s = &quot;abc&quot;; if(s.equals(&quot;abc&quot;)) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; &#125; int div(int a,int b) throws Exception &#123; return a/b;&#125; try catch 捕获异常针对性处理方式 Throw 和 throws 的区别：位置不同 throws 用在函数上 ，后面跟的是异常类，可以跟多个； 而 throw 用在函数内 ，后面跟的 是异常对象。 功能不同： throws 用来声明异常，让调用者只知道该功能可能出现的问题 ，可以给出预先的处理方 式； throw 抛出具体的问题对象，执行到 throw，功能就已经结束了 ，跳转到调用者，并 将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语 句，因为执行不到。 throws 表示出现异常的一种可能性 ，并不一定会发生这些异常； throw 则是抛出了异常 ， 执行 throw 则一定抛出了某种异常对象。 13/04/2018 Page 103 of 283 \\4. 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异 常，真正的处理异常由函数的上层调用处理 JAVA 反射动态语言动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结 构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言， 而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。 反射机制概念 （运行状态中知道类所有的属性和方法） 在 Java 中的反射机制是指 在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法 ；这种动态获取信息以及动态调用对象方 法的功能成为 Java 语言的反射机制。 反射的应用场合编译时类型和运行时类型 在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由 声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如： Person p=new Student(); 其中编译时类型为 Person，运行时类型为 Student 。 13/04/2018 Page 104 of 283 的编译时类型无法获取具体方法 程序在运行时还可能接收到外部传入的对象， 该对象的编译时类型为 Object ,但是程序有需要调用 该对象的运行时类型的方法。为了解决这些问题， 程序需要在运行时发现对象和类的真实信息 。 然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象 和类的真实信息，此时就必须使用到反射了。 Java 反射 API反射 API 用来生成 JVM 中的类、接口或则对象的信息。 Class 类：反射的核心类，可以获取类的属性，方法等信息。 Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性 值。 Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或 者执行方法。 Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。 反射使用步骤（获取 Class 对象、调用对象方法） 获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方 法。 调用 Class 类中的方法，既就是反射的使用阶段。 使用反射 API 来操作这些信息。 获取 Class 对象的 3 种方法调用某个对象的 getClass() 方法 Person p=new Person(); Class clazz=p.getClass(); 调用某个类的 class 属性来获取该类对应的 Class 对象 Class clazz=Person.class; 使用 Class 类中的 forName() 静态方法 ( 最安全 / 性能最好 ) Class clazz=Class.forName(“类的全路径”); (最常用) 当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性。 //获取 Person 类的 Class 对象 Class clazz=Class.forName(“reflection.Person”); 13/04/2018 Page 105 of 283 //获取 Person 类的所有方法信息 Method[] method=clazz.getDeclaredMethods(); for(Method m:method){ System.out.println(m.toString()); } //获取 Person 类的所有成员属性信息 Field[] field=clazz.getDeclaredFields(); for(Field f:field){ System.out.println(f.toString()); } //获取 Person 类的所有构造方法信息 Constructor[] constructor=clazz.getDeclaredConstructors(); for(Constructor c:constructor){ System.out.println(c.toString()); } 创建对象的两种方法Class 对象的 newInstance() 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求 该 Class 对象对应的类有默认的空构造器。 调用 Constructor 对象的 newInstance() 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。 //获取 Person 类的 Class 对象 Class clazz=Class.forName(“reflection.Person”); //使用.newInstane 方法创建对象 Person p=(Person) clazz.newInstance(); //获取构造方法并创建对象 Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class); //创建对象并设置属性 13/04/2018 Page106 of 283 Person p1=(Person) c.newInstance(“李四”,”男”,20); 原作地址：https://www.jb51.net/article/217608.htm","categories":[],"tags":[]},{"title":"Java实现简单系统登录注册模块","slug":"Java实现简单系统登录注册模块","date":"2021-10-17T13:36:01.000Z","updated":"2021-10-17T14:07:50.672Z","comments":true,"path":"2021/10/17/Java实现简单系统登录注册模块/","link":"","permalink":"http://localhost:4000/2021/10/17/Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97/","excerpt":"","text":"前期准备 首先要先明确有个大体的思路，要实现什么样的功能，了解完成整个模块要运用到哪些方面的知识，以及从做的过程中去发现自己的不足。技术方面的进步大都都需要从实践中出来的。功能：用户注册功能+系统登录功能+生成验证码知识：窗体设计、数据库设计、JavaBean封装属性、JDBC实现对数据库的连接、验证码（包括彩色验证码）生成技术，还有就些比如像使用正则表达式校验用户注册信息、随机获得字符串、对文本可用字符数的控制等 设计的模块预览图： 彩色验证码预览图： 所用数据库：MySQL 数据库设计 创建一个数据库db_database01,其中包含一个表格tb_user,用来保存用户的注册的数据。其中包含4个字段id int(11)username varchar(15)password varchar(20)email varchar(45) MySQL语句可以这样设计： 123456789create schema db_database01;use db_database01;create table tb_user(id ``int``(``11``) not ``null` `auto_increment primary key,username varchar(``15``) not ``null``,password varchar(``20``) not ``null``,email varchar(``45``) not ``null);insert into tb_user values(``1``,``&quot;lixiyu&quot;``,``&quot;lixiyu&quot;``,&lt;a href=``&quot;mailto:lixiyu419@gmail.com&quot;``&gt;lixiyu419``@gmail``.com&lt;/a&gt;); 这样把lixiyu作为用户名。select语句检查一下所建立的表格： 编写JavaBean封装用户属性 1234567891011121314151617181920212223242526272829303132package com.lixiyu.model;public class User &#123;private int id;// 编号private String username;// 用户名private String password;// 密码private String email;// 电子邮箱public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id = id;&#125;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username = username;&#125;public String getPassword() &#123;return password;&#125;public void setPassword(String password) &#123;this.password = password;&#125;public String getEmail() &#123;return email;&#125;public void setEmail(String email) &#123;this.email = email;&#125;&#125; 编写JDBC工具类 将与数据库操作相关的代码放置在DBConfig接口和DBHelper类中DBConfig接口用于保存数据库、用户名和密码信息代码： 123456package com.lixiyu.util;public interface DBConfig &#123;String databaseName = &quot;db_database01&quot;;// 数据库名称String username = &quot;root&quot;;// 数据库用户名String password = &quot;lixiyu&quot;;// 数据库密码&#125; 为简化JDBC开发，DBHelper使用了了Commons DbUtil组合。 DBHelper类继承了DBConfig接口，该类中包含4种方法：（1）getConnection()方法：获得数据库连接，使用MySQL数据源来简化编程，避免因加载数据库驱动而发生异常。（2）exists()方法：判断输入的用户名是否存在。（3）check()方法：当用户输入用户名和密码，查询使用check()方法是否正确。（4）save()方法：用户输入合法注册信息后，，将信息进行保存。 详细代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.lixiyu.util;import java.sql.Connection;import java.sql.SQLException;import java.util.Arrays;import java.util.List;import org.apache.commons.dbutils.DbUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.ResultSetHandler;import org.apache.commons.dbutils.handlers.ColumnListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import org.apache.commons.lang.StringEscapeUtils;import com.lixiyu.model.User;import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;public class DBHelper implements DBConfig &#123; /* * 使用MySQL数据源获得数据库连接对象 * * @return：MySQL连接对象，如果获得失败返回null */ public static Connection getConnection() &#123; MysqlDataSource mds = new MysqlDataSource();// 创建MySQL数据源 mds.setDatabaseName(databaseName);// 设置数据库名称 mds.setUser(username);// 设置数据库用户名 mds.setPassword(password);// 设置数据库密码 try &#123; return mds.getConnection();// 获得连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null;// 如果获取失败就返回null &#125; /* * 判断指定用户名的用户是否存在 * * @return：如果存在返回true，不存在或者查询失败返回false */ public static boolean exists(String username) &#123; QueryRunner runner = new QueryRunner();// 创建QueryRunner对象 String sql = &quot;select id from tb_user where username = &#x27;&quot; + username + &quot;&#x27;;&quot;;// 定义查询语句 Connection conn = getConnection();// 获得连接 ResultSetHandler&lt;List&lt;Object&gt;&gt; rsh = new ColumnListHandler();// 创建结果集处理类 try &#123; List&lt;Object&gt; result = runner.query(conn, sql, rsh);// 获得查询结果 if (result.size() &gt; 0) &#123;// 如果列表中存在数据 return true;// 返回true &#125; else &#123;// 如果列表中没有数据 return false;// 返回false &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; DbUtils.closeQuietly(conn);// 关闭连接 &#125; return false;// 如果发生异常返回false &#125; /* * 验证用户名和密码是否正确 使用Commons Lang组件转义字符串避免SQL注入 * * @return：如果正确返回true，错误返回false */ public static boolean check(String username, char[] password) &#123; username = StringEscapeUtils.escapeSql(username);// 将用户输入的用户名转义 QueryRunner runner = new QueryRunner();// 创建QueryRunner对象 String sql = &quot;select password from tb_user where username = &#x27;&quot; + username + &quot;&#x27;;&quot;;// 定义查询语句 Connection conn = getConnection();// 获得连接 ResultSetHandler&lt;Object&gt; rsh = new ScalarHandler();// 创建结果集处理类 try &#123; String result = (String) runner.query(conn, sql, rsh);// 获得查询结果 char[] queryPassword = result.toCharArray();// 将查询到得密码转换成字符数组 if (Arrays.equals(password, queryPassword)) &#123;// 如果密码相同则返回true Arrays.fill(password, &#x27;0&#x27;);// 清空传入的密码 Arrays.fill(queryPassword, &#x27;0&#x27;);// 清空查询的密码 return true; &#125; else &#123;// 如果密码不同则返回false Arrays.fill(password, &#x27;0&#x27;);// 清空传入的密码 Arrays.fill(queryPassword, &#x27;0&#x27;);// 清空查询的密码 return false; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; DbUtils.closeQuietly(conn);// 关闭连接 &#125; return false;// 如果发生异常返回false &#125; /* * 保存用户输入的注册信息 * * @return：如果保存成功返回true，保存失败返回false */ public static boolean save(User user) &#123; QueryRunner runner = new QueryRunner();// 创建QueryRunner对象 String sql = &quot;insert into tb_user (username, password, email) values (?, ?, ?);&quot;;// 定义查询语句 Connection conn = getConnection();// 获得连接 Object[] params = &#123; user.getUsername(), user.getPassword(), user.getEmail() &#125;;// 获得传递的参数 try &#123; int result = runner.update(conn, sql, params);// 保存用户 if (result &gt; 0) &#123;// 如果保存成功返回true return true; &#125; else &#123;// 如果保存失败返回false return false; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; DbUtils.closeQuietly(conn);// 关闭连接 &#125; return false;// 如果发生异常返回false &#125;&#125; **系统登录** **1.1窗体设计** 使用BoxLayout布局，将控件排列方式设置从上至下： 复制代码代码如下: 1contentPane.setLayout(new BoxLayout(contentPane,BoxLayout.PAGE_AXIS)); 窗体使用了标签、文本域、密码域和按钮等控件 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class login extends JFrame&#123;private static final long serialVersionUID = -4655235896173916415L;private JPanel contentPane;private JTextField usernameTextField;private JPasswordField passwordField;private JTextField validateTextField;private String randomText;public static void main(String args[])&#123;try &#123;UIManager.setLookAndFeel(&quot;com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel&quot;);&#125; catch (Throwable e) &#123;e.printStackTrace();&#125;EventQueue.invokeLater(new Runnable()&#123;public void run()&#123;try&#123;login frame=new login();frame.setVisible(true);&#125;catch(Exception e)&#123;e.printStackTrace();&#125;&#125;&#125;); &#125;public login()&#123;setTitle(&quot;系统登录&quot;);setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);contentPane=new JPanel();setContentPane(contentPane);contentPane.setLayout(new BoxLayout(contentPane,BoxLayout.PAGE_AXIS)); JPanel usernamePanel=new JPanel();contentPane.add(usernamePanel); JLabel usernameLable=new JLabel(&quot;\\u7528\\u6237\\u540D\\uFF1A&quot;);usernameLable.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));usernamePanel.add(usernameLable); usernameTextField=new JTextField();usernameTextField.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));usernamePanel.add(usernameTextField);usernameTextField.setColumns(10); JPanel passwordPanel = new JPanel();contentPane.add(passwordPanel);JLabel passwordLabel = new JLabel(&quot;\\u5BC6 \\u7801\\uFF1A&quot;);passwordLabel.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));passwordPanel.add(passwordLabel);passwordField = new JPasswordField();passwordField.setColumns(10);passwordField.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));passwordPanel.add(passwordField);JPanel validatePanel = new JPanel();contentPane.add(validatePanel);JLabel validateLabel = new JLabel(&quot;\\u9A8C\\u8BC1\\u7801\\uFF1A&quot;);validateLabel.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));validatePanel.add(validateLabel);validateTextField = new JTextField();validateTextField.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));validatePanel.add(validateTextField);validateTextField.setColumns(5);randomText = RandomStringUtils.randomAlphanumeric(4);CAPTCHALabel label = new CAPTCHALabel(randomText);//随机验证码label.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));validatePanel.add(label); JPanel buttonPanel=new JPanel();contentPane.add(buttonPanel); JButton submitButton=new JButton(&quot;登录&quot;);submitButton.addActionListener(new ActionListener() &#123;@Overridepublic void actionPerformed(ActionEvent e) &#123;do_submitButton_actionPerformed(e);&#125;&#125;);submitButton.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));buttonPanel.add(submitButton); JButton cancelButton=new JButton(&quot;退出&quot;);cancelButton.addActionListener(new ActionListener()&#123;public void actionPerformed(ActionEvent e)&#123;do_cancelButton_actionPerformed(e);&#125;&#125;);cancelButton.setFont(new Font(&quot;微软雅黑&quot;,Font.PLAIN,15));buttonPanel.add(cancelButton); pack();// 自动调整窗体大小setLocation(com.lixiyu.util.SwingUtil.centreContainer(getSize()));// 让窗体居中显示&#125; 窗体居中显示： 12345678910111213public class SwingUtil &#123;/** 根据容器的大小，计算居中显示时左上角坐标** @return 容器左上角坐标*/public static Point centreContainer(Dimension size) &#123;Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();// 获得屏幕大小int x = (screenSize.width - size.width) / 2;// 计算左上角的x坐标int y = (screenSize.height - size.height) / 2;// 计算左上角的y坐标return new Point(x, y);// 返回左上角坐标&#125;&#125; 1.2获取及绘制验证码 1234567891011121314public class CAPTCHALabel extends JLabel &#123;private static final long serialVersionUID = -963570191302793615L;private String text;// 用于保存生成验证图片的字符串public CAPTCHALabel(String text) &#123;this.text = text;setPreferredSize(new Dimension(60, 36));// 设置标签的大小&#125;@Overridepublic void paint(Graphics g) &#123;super.paint(g);// 调用父类的构造方法g.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 16));// 设置字体g.drawString(text, 5, 25);// 绘制字符串&#125;&#125; 彩色验证码： 12345678910111213141516171819public class ColorfulCAPTCHALabel extends JLabel &#123;private static final long serialVersionUID = -963570191302793615L;private String text;// 用于保存生成验证图片的字符串private Color[] colors = &#123; Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY, Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,Color.PINK, Color.RED, Color.WHITE, Color.YELLOW &#125;;// 定义画笔颜色数组public ColorfulCAPTCHALabel(String text) &#123;this.text = text;setPreferredSize(new Dimension(60, 36));// 设置标签的大小&#125;@Overridepublic void paint(Graphics g) &#123;super.paint(g);// 调用父类的构造方法g.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 16));// 设置字体for (int i = 0; i &lt; text.length(); i++) &#123;g.setColor(colors[RandomUtils.nextInt(colors.length)]);g.drawString(&quot;&quot; + text.charAt(i), 5 + i * 13, 25);// 绘制字符串&#125;&#125;&#125; 1.3非空校验 123456789101112if (username.isEmpty()) &#123;// 判断用户名是否为空JOptionPane.showMessageDialog(this, &quot;用户名不能为空！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;if (new String(password).isEmpty()) &#123;// 判断密码是否为空JOptionPane.showMessageDialog(this, &quot;密码不能为空！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;if (validate.isEmpty()) &#123;// 判断验证码是否为空JOptionPane.showMessageDialog(this, &quot;验证码不能为空！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125; 1.4合法性校验 123456789101112if (!DBHelper.exists(username)) &#123;// 如果用户名不存在则进行提示JOptionPane.showMessageDialog(this, &quot;用户名不存在！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;if (!DBHelper.check(username, password)) &#123;// 如果密码错误则进行提示JOptionPane.showMessageDialog(this, &quot;密码错误！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;if (!validate.equals(randomText)) &#123;// 如果校验码不匹配则进行提示JOptionPane.showMessageDialog(this, &quot;验证码错误！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125; 1.5显示主窗体 12345678910111213EventQueue.invokeLater(new Runnable() &#123;@Overridepublic void run() &#123;try &#123;MainFrame frame = new MainFrame();// 创建主窗体frame.setVisible(true);// 设置主窗体可见&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;&#125;);dispose();// 将登录窗体销毁&#125; 设计主窗体（比较简单这个）： 1234567891011public MainFrame() &#123;setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);// 设置单击关闭窗体按钮时执行的操作setSize(450, 300);// 设置窗体大小contentPane = new JPanel();// 创建面板contentPane.setLayout(new BorderLayout(0, 0));// 设置面板布局使用边界布局setContentPane(contentPane);// 应用面板JLabel tipLabel = new JLabel(&quot;恭喜您成功登录系统！&quot;);// 创建标签tipLabel.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 40));// 设置标签字体contentPane.add(tipLabel, BorderLayout.CENTER);// 应用标签setLocation(SwingUtil.centreContainer(getSize()));// 让窗体居中显示&#125; 用户注册 1.1窗体设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class Register extends JFrame &#123;/****/private static final long serialVersionUID = 2491294229716316338L;private JPanel contentPane;private JTextField usernameTextField;private JPasswordField passwordField1;private JPasswordField passwordField2;private JTextField emailTextField;private JLabel tipLabel = new JLabel();// 显示提示信息/*** Launch the application.*/public static void main(String[] args) &#123;try &#123;UIManager.setLookAndFeel(&quot;com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel&quot;);&#125; catch (Throwable e) &#123;e.printStackTrace();&#125;EventQueue.invokeLater(new Runnable() &#123;@Overridepublic void run() &#123;try &#123;Register frame = new Register();frame.setVisible(true);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;&#125;);&#125;/*** Create the frame.*/public Register() &#123;setTitle(&quot;\\u7528\\u6237\\u6CE8\\u518C&quot;);setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);contentPane = new JPanel();setContentPane(contentPane);contentPane.setLayout(new BoxLayout(contentPane, BoxLayout.PAGE_AXIS));JPanel usernamePanel = new JPanel();contentPane.add(usernamePanel);JLabel usernameLabel = new JLabel(&quot;\\u7528 \\u6237 \\u540D\\uFF1A&quot;);usernameLabel.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));usernamePanel.add(usernameLabel);usernameTextField = new JTextField();usernameTextField.setToolTipText(&quot;\\u8BF7\\u8F93\\u51655~15\\u4E2A\\u7531\\u5B57\\u6BCD\\u6570\\u5B57\\u4E0B\\u5212\\u7EBF\\u7EC4\\u6210\\u7684\\u5B57\\u7B26\\u4E32&quot;);AbstractDocument doc = (AbstractDocument) usernameTextField.getDocument();doc.setDocumentFilter(new DocumentSizeFilter(15));// 限制文本域内可以输入字符长度为15doc.addDocumentListener(new DocumentSizeListener(tipLabel, 15));usernameTextField.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));usernamePanel.add(usernameTextField);usernameTextField.setColumns(10);JPanel passwordPanel1 = new JPanel();contentPane.add(passwordPanel1);JLabel passwordLabel1 = new JLabel(&quot;\\u8F93\\u5165\\u5BC6\\u7801\\uFF1A&quot;);passwordLabel1.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));passwordPanel1.add(passwordLabel1);passwordField1 = new JPasswordField();doc = (AbstractDocument) passwordField1.getDocument();doc.setDocumentFilter(new DocumentSizeFilter(20));// 限制密码域内可以输入字符长度为20doc.addDocumentListener(new DocumentSizeListener(tipLabel, 20));passwordField1.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));passwordField1.setColumns(10);passwordPanel1.add(passwordField1);JPanel passwordPanel2 = new JPanel();contentPane.add(passwordPanel2);JLabel passwordLabel2 = new JLabel(&quot;\\u786E\\u8BA4\\u5BC6\\u7801\\uFF1A&quot;);passwordLabel2.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));passwordPanel2.add(passwordLabel2);passwordField2 = new JPasswordField();doc = (AbstractDocument) passwordField2.getDocument();doc.setDocumentFilter(new DocumentSizeFilter(20));// 限制密码域内可以输入字符长度为20doc.addDocumentListener(new DocumentSizeListener(tipLabel, 20));passwordField2.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));passwordField2.setColumns(10);passwordPanel2.add(passwordField2);JPanel emailPanel = new JPanel();contentPane.add(emailPanel);JLabel emailLabel = new JLabel(&quot;\\u7535\\u5B50\\u90AE\\u7BB1\\uFF1A&quot;);emailLabel.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));emailPanel.add(emailLabel);emailTextField = new JTextField();doc = (AbstractDocument) emailTextField.getDocument();doc.setDocumentFilter(new DocumentSizeFilter(45));// 限制文本域内可以输入字符长度为45doc.addDocumentListener(new DocumentSizeListener(tipLabel, 45));emailTextField.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));emailPanel.add(emailTextField);emailTextField.setColumns(10);JPanel buttonPanel = new JPanel();contentPane.add(buttonPanel);JButton submitButton = new JButton(&quot;\\u63D0\\u4EA4&quot;);submitButton.addActionListener(new ActionListener() &#123;@Overridepublic void actionPerformed(ActionEvent e) &#123;do_submitButton_actionPerformed(e);&#125;&#125;);buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.LINE_AXIS));tipLabel.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));buttonPanel.add(tipLabel);Component glue = Box.createGlue();buttonPanel.add(glue);submitButton.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));buttonPanel.add(submitButton);JButton cancelButton = new JButton(&quot;\\u53D6\\u6D88&quot;);cancelButton.addActionListener(new ActionListener() &#123;@Overridepublic void actionPerformed(ActionEvent e) &#123;do_cancelButton_actionPerformed(e);&#125;&#125;);cancelButton.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 15));buttonPanel.add(cancelButton);pack();// 自动调整窗体大小setLocation(SwingUtil.centreContainer(getSize()));// 让窗体居中显示&#125; 1.2用DocumentFilter限制文本可用字符数 12345678910111213141516171819202122public class DocumentSizeFilter extends DocumentFilter &#123;private int maxSize;// 获得文本的最大长度public DocumentSizeFilter(int maxSize) &#123;this.maxSize = maxSize;// 获得用户输入的最大长度&#125;@Overridepublic void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException &#123;if ((fb.getDocument().getLength() + string.length()) &lt;= maxSize) &#123;// 如果插入操作完成后小于最大长度super.insertString(fb, offset, string, attr);// 调用父类中的方法&#125; else &#123;Toolkit.getDefaultToolkit().beep();// 发出提示声音&#125;&#125;@Overridepublic void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException &#123;if ((fb.getDocument().getLength() + text.length() - length) &lt;= maxSize) &#123;// 如果替换操作完成后小于最大长度super.replace(fb, offset, length, text, attrs);// 调用父类中的方法&#125; else &#123;Toolkit.getDefaultToolkit().beep();// 发出提示声音&#125;&#125;&#125; 1.3用DocumentListener接口实现显示文本控件已用字符 123456789101112131415161718192021222324252627282930public class DocumentSizeListener implements DocumentListener &#123;private JLabel tipLabel;private int maxSize;public DocumentSizeListener(JLabel tipLabel, int maxSize) &#123;this.tipLabel = tipLabel;this.maxSize = maxSize;&#125;@Overridepublic void insertUpdate(DocumentEvent e) &#123;setTipText(e);&#125;@Overridepublic void removeUpdate(DocumentEvent e) &#123;setTipText(e);&#125;@Overridepublic void changedUpdate(DocumentEvent e) &#123;setTipText(e);&#125;private void setTipText(DocumentEvent e) &#123;Document doc = e.getDocument();// 获得文档对象tipLabel.setForeground(Color.BLACK);// 设置字体颜色if (doc.getLength() &gt; (maxSize * 4 / 5)) &#123;// 如果已输入字符长度大于最大长度的80%tipLabel.setForeground(Color.RED);// 使用红色显示提示信息&#125; else &#123;tipLabel.setForeground(Color.BLACK);// 使用黑色显示提示信息&#125;tipLabel.setText(&quot;提示信息：&quot; + doc.getLength() + &quot;/&quot; + maxSize);&#125;&#125; 1.4非空校验 12345678910111213141516if (username.isEmpty()) &#123;// 判断用户名是否为空JOptionPane.showMessageDialog(this, &quot;用户名不能为空！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;if (new String(password1).isEmpty()) &#123;// 判断密码是否为空JOptionPane.showMessageDialog(this, &quot;密码不能为空！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;if (new String(password2).isEmpty()) &#123;// 判断确认密码是否为空JOptionPane.showMessageDialog(this, &quot;确认密码不能为空！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;if (email.isEmpty()) &#123;// 判断电子邮箱是否为空JOptionPane.showMessageDialog(this, &quot;电子邮箱不能为空！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125; 1.5使用正则表达式校验字符串（合法性校验） 1234567891011121314151617181920// 校验用户名是否合法if (!Pattern.matches(&quot;\\\\w&#123;5,15&#125;&quot;, username)) &#123;JOptionPane.showMessageDialog(this, &quot;请输入合法的用户名！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;// 校验两次输入的密码是否相同if (!Arrays.equals(password1, password2)) &#123;JOptionPane.showMessageDialog(this, &quot;两次输入的密码不同！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;// 校验电子邮箱是否合法if (!Pattern.matches(&quot;\\\\w+@\\\\w+\\\\.\\\\w+&quot;, email)) &#123;JOptionPane.showMessageDialog(this, &quot;请输入合法的电子邮箱！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;// 校验用户名是否存在if (DBHelper.exists(username)) &#123;JOptionPane.showMessageDialog(this, &quot;用户名已经存在&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125; 1.6保存注册信息 1234567891011121314User user = new User();user.setUsername(username);user.setPassword(new String(password1));user.setEmail(email);Arrays.fill(password1, &#x27;0&#x27;);// 清空保存密码的字符数组Arrays.fill(password2, &#x27;0&#x27;);// 清空保存密码的字符数组if (DBHelper.save(user)) &#123;JOptionPane.showMessageDialog(this, &quot;用户注册成功！&quot;, &quot;提示信息&quot;, JOptionPane.INFORMATION_MESSAGE);return;&#125; else &#123;JOptionPane.showMessageDialog(this, &quot;用户注册失败！&quot;, &quot;警告信息&quot;, JOptionPane.WARNING_MESSAGE);return;&#125;&#125; 至此，一个简单而有完整的登陆注册模块就完成了。 以上就是本文的全部内容，希望大家可以喜欢。","categories":[],"tags":[]}],"categories":[],"tags":[]}